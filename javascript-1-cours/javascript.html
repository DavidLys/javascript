<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>JavaScript</title>

</head>
<body>
<h1>JavaScript</h1>

<hr />

<p>Mars 2014 - <a href="mailto:stephane.frenot@insa-lyon.fr">Stéphane Frénot</a>, INSA Lyon / Telecom</p>

<p>JavaScript est un langage de programmation initialement introduit dans les navigateurs Web afin de rendre les pages HTML plus dynamiques dans leurs interactions avec l'utilisateur. Des optimisations en performances lui ont permis de se hisser comme un langage de programmation efficace aussi bien au niveau du client qu'au niveau du serveur. Il est nécessaire dans une cadre d'ingénieurie informatique de bien connaitre ce langage dans le contexte du Web actuel, car vous serez nécessairement confronté un jour à son utilisation. S'il est souvent présenté comme un langage mal conçu, il est en passe de devenir le langage de référence d'Internet. Certains groupes comme Google ont véritablement parié sur ce langage autant que sur l'alternative Java par exemple. Ce cours essaye d'expliquer rapidement le contexte d'utilisation de JavaScript afin d'en comprendre les pièges et les freins initiaux.</p>

<p>Le livre à lire est : <a href="http://eloquentjavascript.net/">Eloquent Javascript</a></p>

<p>JavaScript est un langage faiblement typé, avec peu de contrôle.</p>

<p><strong>Avez-vous une idée de la raison ?</strong></p>

<h2>Un langage 'classique' basé sur des fonctions et des algorithmes</h2>

<p>On parle de langage impératif, car vous explicitez les algorithmes de traitement que vous voulez exécuter.</p>

<h3>Lancement</h3>

<p>Nous utiliserons <a href="http://nodejs.org">nodejs</a>, comme interpréteur de programme javascript. Il existe deux manières de l'utiliser.</p>

<pre><code>node // pour lancer l'interpreteur interactif
node toto.js // pour lancer un script javascript
</code></pre>

<p>Il n'existe pas de programme 'le plus simple' car il n'y a aucune contrainte imposée par le langage. Par exemple, il n'y a pas de phase de compilation, ou de contrôle. Voici un exemple de programme simple. (Evidemment, on peut faire plus simple). Pour voir le résultat d'exécution, vous pouvez ouvrir la console javascript dans votre navigateur ou utiliser nodejs en mode interactif.</p>

<pre><code>i = 1
console.log("coucou " + i)
</code></pre>

<p><strong>Essayez donc ce programme dans les deux modes</strong> <br/>
<strong>Quels sont vos commentaires ?</strong></p>

<p>Vous pouvez également lancer ce programme dans votre navigateur Web préféré. Soit avec la console interactive, soit en écrivant une page html qui charge le script.</p>

<pre><code>&lt;html&gt;
   &lt;script src="./toto.js"&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<h3>Les types de données</h3>

<p>Une variable n'a pas a être déclarée, elle sera 'typé' en fonction de son usage.</p>

<pre><code>1. numériques : i = 2012 //Attention la limite est de 2^52 (10^15)
2. string : a = "coucou"    
3. booleen : b = true
</code></pre>

<p>Une variable peut être déclarée avant son usage avec le mot clé var. Elle est alors initialisée à "undefined".</p>

<pre><code>var x 
console.log(x)
</code></pre>

<h3>Les structures de controle</h3>

<p>javascript possède des structures de controle algorithmiques comme tous les langages.</p>

<pre><code>if / else if / else
while ()
do {} while ()
for () / break
switch() / case / break
</code></pre>

<h3>Les fonctions</h3>

<p>javascript permet de capturer les algorithmes dans des fonctions. Le programme initial (votre navigateur ou votre interpréteur javascript) est également une fonction.</p>

<pre><code>function somme(a, b) {
   return a+b
}

console.log(somme(2,3))
</code></pre>

<p><em>Les ';' sont optionnels si vous avez une instruction par ligne. Mais on est souvent habitué à mettre un ';'</em></p>

<p><strong>Ecrire le programme correspondant à somme en javascript et en Java, exécuter. Quels sont vos commentaires ?</strong></p>

<h2>Un langage 'avancé' basé sur les fonctions</h2>

<p>Javascript est un langage issu de la communauté des langages fonctionnels stricts (scheme). Il présente une caractéristique forte d'être compatible avec ce paradigme (sans la notion de pureté). C'est à dire que les fonctions sont des élements de premier ordre, au même niveau que les variables. Ainsi une variable peut être de type fonction, et une fonction peut être passée en paramètre à une autre fonction ou passée comme retour de fonction.</p>

<h3>Avant d'aller dans les détails fonctionnels</h3>

<p>Evacuons un côté humoristique de javascript.</p>

<pre><code>null == undefined
false == 0
"" == 0
"5" == 5
</code></pre>

<p><strong>Quelqu'un a une explication ?</strong>
<strong>La solution est...</strong>
<strong>Rejouez les tests avec ===</strong></p>

<p>Quelques codes désagréables</p>

<pre><code>var peutEtreNull = null;
if (peutEtreNull) {
  console.log("Peut etre nul")
}

"Appolo" + 5
null + "ify"
"5" * 5
"strawberry" * 5
</code></pre>

<p><strong>Comment "blinder" tout cela ?</strong></p>

<h3>Bon, passons aux choses sérieuses avec nos fonctions</h3>

<p>Une variable peut être de type fonction (et c'est là que ca va commencer à faire mal à la tête.)</p>

<pre><code>var a = function(a,b) { return a + b }
console.log(a(4,5))
</code></pre>

<p>Et évidemment, on peut maintenant tout péter, car on peut mettre n'importe quoi dans une fonction. En gros il n'y aucune règle.</p>

<pre><code>console.log = "a"
</code></pre>

<p>C'est quoi une fermeture (closure) ?</p>

<pre><code>function create() {
  var reponse = 23;
  return function (x) { return x + reponse; }
}

var a = create()
console.log(a(12))
</code></pre>

<p>Nombre de paramètres d'une fonction ?</p>

<pre><code>function moins(a, b, c) {
  return (a - b);
}

console.log(moins(3, 2));
console.log(moins(3, 2, 4, 8));
console.log(moins(2));
</code></pre>

<p>Mais ca sert à quoi d'avoir mal à la tête ?</p>

<pre><code>function additionneur(x) {
  return function (a) { return a + x }
}

var plusDeux = additionneur(2);
var plusTrois = additionneur(3);

console.log (plusDeux(10))
console.log (plusTrois(2))
</code></pre>

<p>Pour les intimes, plusDeux() et plusTrois() s'appellent des functorObjects.
Additionneur est une fonction d'ordre supérieur. C'est une fonction qui renvoie une fonction.</p>

<p><strong><em> Ecrire la fonction d'ordre supérieur qui permet de composer une addition et une multiplication. Pour fabriquer des functeurs comme add4plus3.</em></strong></p>

<h3>Allons, respirons un peu avec les objets et les tableaux</h3>

<p>Un objet n'est pas un objet Java ... Mais une HashMap, une Map, un tableau Associatif. Bref une structure qui gère des équivalences clé valeurs. (Mais souvenez-vous qu'une valeur peut être une fonction par exemple, et là ca risque de ressembler à un objet Java ...).</p>

<pre><code>var chose = { "hello" : "coucou", 3:10}
chose["3"];
-&gt; 10
chose.hello;
-&gt; coucou
delete chose.hello;
chose
for (o in chose) {
  console.log( o + '-&gt;' + chose[o])
} 
</code></pre>

<p>Les tableaux existent évidemment.</p>

<pre><code>mesAmis = ["bob", "raoul", "louis"]
for (i = 0; i &lt; mesAmis.length; i++) {
  console.log("-&gt;" + mesAmis[i]);
}
tesAmis = new Array();
tesAmis.push(1);
tesAmis.push('leon');
</code></pre>

<p><strong>Une petite remarque. Dans l'exemple précédent, que se passe t'il si on remplace :
 console.log("->" + mesAmis[i]), par console.log("->", mesAmis[i])</strong></p>

<h3>Les méthodes</h3>

<pre><code>doe = "Doe"
typeof doe.toUpperCase
doe.toUpperCase()    
</code></pre>

<h3>Les variables automatiques</h3>

<pre><code>function arguments() {
  return "Vous avez fourni " + arguments.length + " arguments.";
}
arguments(1, 2, 3, "toto")
</code></pre>

<p><strong><em>Une remarque particulière sur le code précédent ?</em></strong></p>

<h3>Les exceptions</h3>

<p>Pareil que pour java / throw + try/catch</p>

<h3>Les fonctions d'ordre supérieur. Ou l'approche fonctionnelle</h3>

<p>Ce sont des fonctions qui prennent des fonctions en parametre, et peuvent donc les appliquer dans leur exécution.</p>

<pre><code>function afficheTableau(tableau) {
  for (i = 0; i &lt; tableau.length; i++; ) {
    console.log(tableau[i])
  }
}
</code></pre>

<p><strong>Console.log est une fonction... Transformez donc ce code dans une fonction générique <code>forEach</code> permettant d'appliquer une fonction quelconque à tous les membres du tableau. Utilisez-là pour afficher les valeurs du tableau sur la console, puis pour faire une somme d'éléments d'un tableau</strong></p>

<p>On peut donc également renvoyer une fonction. Que fait la fonction suivante ?</p>

<pre><code>function negate(func) {
  return function(x) {
    return !func(x)
  }
}
</code></pre>

<p><strong>Ecrire la fonction de comparaison d'un nombre par rapport à 0 et appliquez la version negate dessus.</strong></p>

<p> En plus générique.</p>

<pre><code>function negate(func) {
  return function() {
    return !func.apply(null, arguments)
  }
}
</code></pre>

<p><strong>Qu'est ce que que cela apporte ?</strong></p>

<p> On peut finir avec le célèbre map/reduce.</p>

<p>Le réduce permet, en partant d'une valeur initiale, d'appliquer une fonction (connue dans le futur) à tous les éléments d'un tableau, afin de le réduire à une valeur unique.</p>

<pre><code>function reduce(future, base, tableau) {
  tableau.forEach(function (element) { // Ai-je déjà parlé des fonctions anonymes ?
    base = future(base, element)
  });
  return base
}

--- Utilisation
function add(a, b) { // Ceci est la fonction à utiliser dans le futur
  return a + b
}

function sum(nombres) {
  return reduce (add, 0, nombres)
}
</code></pre>

<p>Le map fabrique un nouveau tableau à partir de l'application d'une fonction sur tous les éléments du premier tableau.</p>

<p><strong>A vous de l'écrire.</strong></p>

<p>Quelques autres éléments sur la programmation fonctionnelle.</p>

<pre><code>var op = {
  "+": function (a, b) { return a+b; },
  "-": function (a, b) { return a-b; }
}

reduce (op["+"], 0, [1, 2, 3]) // On gagne la déclaration d'une fonction add

function partial (func) { // La fonction construit une nouvelle fonction, avec des       paramètres partiellement fournis
  var knownArgs = arguments;
  return function () {
    var realArgs = [];
    for (var i=1; i &lt; knownArgs.length; i++) {
      realArgs.push(knownArgs[i]);
    }  
    for (var i=0; i&lt;arguments.length;i ++) {
      realArgs.push(arguments[i]);
    }  
    return func.apply(null, realArgs);
  };  
}

map(partial(op["+"],1), [0,2,4]))  // Ici ca devient vraiment fonctionnel ...   
</code></pre>

<p><strong>Que fait le code fonctionnel suivant ?</strong></p>

<pre><code>function aDécouvrir(f1, f2) {
  return function () {
    return f1(f2.apply(null, arguments))
  }
}    
</code></pre>

<h2>Passons aux objets (de l'objet !!)</h2>

<p>Les objets en trois étapes</p>

<pre><code>var lapin = {};
lapin.parle = function (phrase) {
  console.log("Le lapin dit '", phrase, "'");
}
lapin.parle("Je suis vivant.");
</code></pre>

<p>Mais aussi</p>

<pre><code>function parle (phrase) {
  console.log("Le lapin ", this.couleur, " dit '", phrase, "'");
}
var lapinBlanc = { couleur : "blanc", parle : parle };
var lapinNoir = { couleur : "noir", parle : parle };

lapinBlanc.parle(" Je suis tout blanc ");
lapinNoir.parle(" Je suis tout noir ");


lapin.parle(" je suis blanc ")
==
parle.apply(lapin, ["je suis blanc"]);
==
parle.call(lapin, "je suis blanc");
</code></pre>

<p>On peut appliquer l'opérateur new sur une fonction. Je vous suggère d'écrire cette fonction avec une première lettre en majuscule.</p>

<pre><code>function Lapin (couleur) {
  this.couleur = couleur;
  this.parle = function (phrase) {
    console.log("Le lapin ", this.couleur, " dit '", phrase, "'");
  };
}

var lapinTueur = new Lapin(" tueur ");
lapinTueur.parle(" GRRRAAAAAAHHHH ");

------
function fabriqueMoiUnLapin(couleur) {
  return {
    couleur: couleur,
    parle: function(phrase) { /***/ }
  };
}
var lapinNoir = fabriqueMoiUnLapin("black");
</code></pre>

<p>C'est ici qu'on découvre que javascript est un langage orienté prototype... Le prototype est un objet présent dans toutes les fonctions qui référence toute les fonctions disponibles à partir de celle-ci. Positionner une propriété n'affecte jamais le prototype. Rechercher une propriété se fait dans l'objet, puis dans le prototype, puis dans le prototype du prototype. Les prototypes sont chaînés.</p>

<pre><code> Lapin.prototype.dents = "petites";
 lapinTueur.dents;
 --&gt; "petites"
 lapinTueur.dents = "longues et ascérées"
 lapinTueur.dents;
 --&gt; "longues et ascérées";
 Lapin.prototype.dents;
 --&gt; "petites";
 "longues et ascérées"
</code></pre>

<p><img src="prototype.jpg" width="250" title="Prototypes" alt="Prototypes" /></p>

<p>Voici un schema de départ de description d'une fonction.
<img src="this.png" title="This" alt="This" /></p>

<pre><code>MyConstructor = function () {
  this.a = "debut";
}
MyConstructor.protype.b = "fin";
var j = new MyConstructor();
console.log(j.a, j.b);
</code></pre>

<p><img src="this-a.jpg" title="This-a" alt="This" /></p>

<p>Ce que fait l'operateur new est donc :</p>

<ol>
<li>Crée un nouvel objet (j). Le type de l'objet est object.</li>
<li>Positionne la propriété interne non accessible [[prototype]] vers la fonction pointée par le prototype de la function (MyConstructor.prototype).</li>
<li>Exécute le constructeur de ce prototype, en remplacant this par le nouvel objet créé (j) (j.a -> "debut")</li>
<li>Renvoie l'objet nouvellement créé, sauf si le constructeur retourne une valeur non primitive</li>
</ol>


<p>Quand une propriété est recherchée, elle l'est dans l'objet puis dans tous les  prototypes enchainés.</p>

<p>Un dernier détail important sur le mot clé <code>this</code> représente l'objet qui 'possède' la fonction qui s'exécute.</p>

<pre><code>var i = 30
function f () {
  var i = 15;
  console.log(i);
  console.log(this.i);
}
f()
</code></pre>

<p><strong>L'exemple est clair ?</strong></p>

<h2>Quelques petits soucis sur le prototypage</h2>

<p>Tous les objets possèdent des propriétés. Les leurs, celles des prototypes, et de la chaîne des prototypes.</p>

<p>Exemple 1</p>

<pre><code>var lesEtudiants = {};
if ("constructor" in lesEtudiants) {
   console.log("Oui, il y a un étudiants qui s'appelle 'constructor'");
}
</code></pre>

<p>Exemple 2 : Ecrire une fonction qui permet de lister les proprietés d'un objet.</p>

<pre><code>var test = {x:10, y:3};
console.log(test.properties());
</code></pre>

<p>On est sauvé avec la methode hasOwnProperty qui permet de vérifier que la propriété est véhiculé par l'objet et non pas par son prototype.</p>

<p>On peut donc ecrire le programme fonctionnel suivant :</p>

<pre><code>function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  }
}

var etudiants = {"sfrenot" : {nom: "frenot", prenom : "stephane", age : "22"},
                 "lmametz" : {nom: "mametz", prenom : "laurent"}};
forEachIn(etudiants, function(name, value) {
  console.log("nom : ", name, " -&gt; valeur ", value);
});
</code></pre>

<p><strong>Que se passe t'il si un étudiant s'appelle 'hasOwnProperty' ?
Voyez-vous une solution ? (Changer d'ordre par exemple ...)</strong></p>

<h2>Un dernier point sur la modularité et la notion d'interface de service</h2>

<p>On veut faire un 'module' qui 'exporte' deux fonctions publiques de conversion.
Comment fonctionne ce programme ?</p>

<pre><code>function buildMonthNameModule() {
  var names = ["January", "February", "March", "April",
           "May", "June", "July", "August", "September",
           "October", "November", "December"];
  function getMonthName(number) {
    return names[number];
  }
  function getMonthNumber(name) {
    for (var number = 0; number &lt; names.length; number++) {
      if (names[number] == name)
        return number;                    }
  }

  window.getMonthName = getMonthName;
  window.getMonthNumber = getMonthNumber;
}

buildMonthNameModule();

show(getMonthName(11));
</code></pre>

<p><strong>Quels sont les problèmes de cette modularité ?</strong></p>

<p>1 Supprimer les déclarations multiples (chaque déclaration est source d'erreur de nom)</p>

<pre><code>function register(publicFunc) {
  forEachIn(publicFunc, function(name, value) {
     window[name] = value;
  });
}

function buildMonthNameModule() {
  var names = ["January", "February", "March", "April",
           "May", "June", "July", "August", "September",
           "October", "November", "December"];
  register ({
    getMonthName: function(number) {
      return names[number];
    },
    getMonthNumber: function(name) {
      for (var number = 0; number &lt; names.length; number++) {
        if (names[number] == name)
          return number;
      }
    }
  });
 }   

 buildMonthNameModule();
 console.log(getMonthName(11));
</code></pre>

<p>2 Supprimer la fonction déclarée au top niveau
    En la rendant anonyme et en l'exécutant. Pour l'exécuter, il faut y mettre quelques parenthèses !!!</p>

<pre><code>(function() {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
           "Thursday", "Friday", "Saturday"];
  register({
    getDayName: function(number) {
      return names[number];
    },
    getDayNumber: function(name) {
      for (var number = 0; number &lt; names.length; number++) {
        if (names[number] == name)
          return number;
      }
    }
  });
})();
</code></pre>

<p>2.1 On peut enfin passer un paramètre externe à cette fonction... Ce code vous dit-il quelque chose ?</p>

<pre><code>(function() {
  var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
           "Thursday", "Friday", "Saturday"];
  console.log(" $ -&gt; ", $)
  register({
    getDayName: function(number) {
      return names[number];
    },
    getDayNumber: function(name) {
      for (var number = 0; number &lt; names.length; number++) {
        if (names[number] == name)
          return number;
      }
    }
  });
})($);             
</code></pre>

<p>Et voilà un beau module qui déclare deux fonctions publiques, en conservant les attributs privés (C'est ce qu'on cherche à faire en POO non ?)</p>

<p>Pour se détendre <a href="https://www.destroyallsoftware.com/talks/wat">wat</a><br/>
Linux dans javascript <a href="http://bellard.org/jslinux/">bellard</a><br/>
Douglas Crockford, javascript leader <a href="http://en.wikipedia.org/wiki/Douglas_Crockford">crockford</a><br/>
Description du new <a href="http://stackoverflow.com/questions/383402/is-javascript-s-new-keyword-considered-harmful">stackOverflow</a><br/>
Description du this <a href="http://stackoverflow.com/questions/1646698/what-is-the-new-keyword-in-javascript">stackOverflow</a><br/>
Dessin du this<a href="http://zeekat.nl/articles/constructors-considered-mildly-confusing.html">schema this</a><br/>
Programmation fonctionelle <a href="https://www.youtube.com/watch?v=FITJMJjASUs">ruby</a></p>

<hr />

<h1>Pourquoi faire du JavaScript ?</h1>

<p>Javascript est certainement aujourd'hui le plus gros ecosystème numérique. Il va concerner les aspects communautaires suivants :</p>

<ul>
<li>Développement d'applications :

<ul>
<li>n'importe qui peut développer en Javascript, et l'exécuter sans 'temps mort'.</li>
<li>Démarrer par les interfaces Web permet d'avoir un MVP<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> tiré par l'usage (UX).</li>
<li>L'infrastructure nodejs<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> permet d'envisager des développements logiciels monolangages de bout en bout. LinkedIn, NetFlix, Paypal</li>
</ul>
</li>
<li>Développement de plugins : (Nature fonctionnelle)

<ul>
<li>Les fonctions basiques sont développés de manière autonomes. Certains plugins sont maintenant incontournables :

<ul>
<li>jquery</li>
<li>underscore</li>
<li>bootstrap</li>
</ul>
</li>
<li>Nombreux gestionnaires de bibliothèques : bower (client), npm (serveur), require, standardisation des modules</li>
</ul>
</li>
<li>Intégration dans tous les grands systèmes : facebook, linkedin</li>
<li>Infrastructures de référence : angularjs, amberjs, phonegap, cordovajs,</li>
<li>Runtime : os, nodejs, v8, navigateurs

<ul>
<li>Navigateurs Web : fixe, tablettes, smartphone</li>
<li>Machines virtuelles : v8, fantomjs</li>
<li>Systèmes d'exploitation</li>
</ul>
</li>
<li>Sur Langages : coffeescript, typescript</li>
</ul>


<hr />

<ul>
<li>Assembleur du web</li>
<li>Jungle stimulante</li>
<li>Approche modulaire/fonctionnelle, facile de développer</li>
<li>Pas de 'spécialiste' de domaine précis</li>
<li>Effet reseau (github)</li>
<li>Normalisation ECMA</li>
</ul>


<hr />

<ul>
<li>Le but n'est pas d'enseigner exclusivement JavaScript, mais d'être prêt sur le plus gros ecosystème connu.</li>
<li>Menaces : dart, jungle complexe (mais vrai challenge), mauvais programmeur (mais c'est le cas dans tous les langages).</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Minimum Viable Product : Lean startup, E. Ries<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>NodeJs : <a href="http://nodejs.org">http://nodejs.org</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</body>
</html>