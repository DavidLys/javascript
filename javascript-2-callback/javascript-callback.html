<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Pourquoi faut-il des callback en Javascript ?[^1]</title>

</head>
<body>
<h1>Pourquoi faut-il des callback en Javascript ?<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h1>

<p>Javascript propose la mise en place de callback, car le langage ne possède pas de support pour des exécution multithreadées, et que le mécanisme de callback est l'unique solution pour ne pas bloquer une exécution.   <br/>
Explications : L'objectif de ce TD est de réaliser un certain nombre d'exercices afin de comprendre le principe du callback.</p>

<h2>Faire une page html qui exécute un simple script contenant une fonction "coûteuse"</h2>

<p>Il est possible qu'une fonction bloque de manière assez brutale une page html.</p>

<p><strong><em>Exercice 1</em></strong> Montrez, qu'à partir d'un certain "coût" de la fonction, la page à du mal à s'afficher.</p>

<pre><code>&lt;html&gt;
  Hello world
  GoodBye World
  &lt;script src="exercice1.js"&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><br /></p>

<pre><code>function call1 () {
  console.log("i --&gt;" + i);
}

for (i = 0; i &lt; 200; i++) {
  call1();
 }
</code></pre>

<p>Conclusions ? Commentaires ?</p>

<h2>Comprendre l'eventStack</h2>

<p>La politique d'exécution d'une page html repose principalement sur un seul thread d'exécution. La fonction setTimeout, permet de placer dans la pile des prochaines fonctions à exécuter une fonction particulière.
Javascript exécute cette pile fonction après fonction dans l'ordre de la pile. Par exemple :</p>

<table>
<thead>
<tr>
<th>Pile d'appel</th>
</tr>
</thead>
<tbody>
<tr>
<td>main() </td>
</tr>
<tr>
<td>call1() </td>
</tr>
</tbody>
</table>


<p>Javascript exécutera la f1, puis f2, puis f3. Après l'appel
setTimeout(f4, 200, 3), javascript placera la fonction f4 après 200 ms à la suite des fonctions à exécuter</p>

<table>
<thead>
<tr>
<th>Pile t1 </th>
<th> Pile t2 </th>
<th> Pile t3 </th>
<th> Pile t4</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td> call1(1) </td>
<td> call1() </td>
<td> ...</td>
</tr>
</tbody>
</table>


<p>===> Langage turn based</p>

<p><strong><em>Exercice 2</em></strong>
Transformez le compteur précédent, dans une fonction strictement équivalente mais qui ne bloque pas le client.</p>

<h2>L'arrivée du callback</h2>

<p>On repart sur le pattern d'écriture de fonction non bloquante suivant :</p>

<pre><code>//Pattern
function call1 () {
  function _call1(i) {
  //Ancienne fonction
    i++;
    console.log("i --&gt;" + i);
    if (i &lt; 2000) {
    //Pattern
      setTimeout(_call1, 0, i);
    } 
   }
  _call1(0);
  return 'ok';
 }

 call1()
</code></pre>

<p>Comment récupérer la terminaison de la fonction call1 ?</p>

<p>Montrez ce qui se passe quand on traite la question de manière synchrone ?</p>

<p>Le pattern précédent ne bloque plus le client ! Certe, mais celui-ci ne sait alors plus quand la fonction se termine. Il est alors impossible d'écrire un programme, qui, à la fois utilise un code non-bloquant d'appel de fonction et qui bloque l'appelant le temps de son exécution.</p>

<p>Pour résoudre ce problème, on passe par le célèbre mécanisme de callback de Javascript. Qui est intimement lié au mécanisme de closure.</p>

<p>Un appel synchrone/bloquant s'écrit classiquement ainsi
<code>ret = f3(25)</code>, bloque l'appelant le temps que f3 s'éxécute avec le paramètre <code>25</code>, et lui transmet le résultat dans la variable ret à la fin. Dans javascript les appels ne peuvent plus être bloquants, et la syntaxe précédent ne véhicule aucune information dans un certain nombre de cas.</p>

<p>Une convention à été choisie qui utilise le dernier paramètre d'une fonction asynchrone en tant que fonction que l'appelé utilisera pour notifier l'appelant de la fin de son exécution.</p>

<p>L'appel équivalent asynchrone devient :
<code>f3(25, function() { console.log("Appel terminé");} )</code></p>

<p>On remarquera l'utilisation d'une fonction anonyme comme dernier paramètre de l'appel, car oui, Javascript est un langage fonctionnel. C'est à dire que les paramètre d'une fonction peuvent être du type fonction. (Ce qui n'est pas possible dans les langages non fonctionnel comme Java par exemple).</p>

<p><strong><em>Exercice 3</em></strong> Transformez le code de la fonction coût pour notifier l'appelant à la fin de l'exécution. Montrez par la même occasion que l'appelant n'est pas bloqué dans son exécution, et que pourtant il ne 'quite pas' ; ce qui illustre le mécanisme de closure.</p>

<h2>L'enchaînement des callbacks</h2>

<p>L'utilisation des callback, permet donc de réaliser un programme sychrone non bloquant pour l'appelant, exécutant une suite d'action en fonction du résultat des actions précédentes alors que le contrôle global est fait de manière asynchrone non bloquante.</p>

<p><strong><em>Exercice 4</em></strong> Ecrivez le programme à base de callback équivalent à cet appel "classique".
    ret1 = appelBloquant1();
    ret2 = appelBloquant2();
    ret3 = appelBloquant3();</p>

<p>C'est à dire, formulé différemment, un programme garantissant que l'ordre d'appel des fonctions est conservé strictement. appelBloquant1 > appelBloquant2 > appelBloquant3, quelque soit le comportement d'attente des fonctions.</p>

<p><strong>Gardez bien à l'esprit que les appelBloquants peuvent potentiellement coûter très chers, mais ne doivent pas perturber le navigateur</strong></p>

<h2>L'enfer des callbacks</h2>

<p>Les callbacks génèrent une structure de lecture qui n'est pas alignée avec la structure d'exécution. Ceci est habituellement appelé l'enfer des callbacks.</p>

<p><strong><em>Exercice 5</em></strong> indiquez l'ordre d'apparition des messages le plus probable du code suivant.</p>

<pre><code>console.log("A");
call1(function() {
  console.log("B");
  call2(function() {
    console.log("C");
    call3(function() {
      console.log("D");
    });
    console.log("E");
  });
  console.log("F");
});
console.log("G");
</code></pre>

<p>Il est clair que ce code, est moins clair que :</p>

<pre><code>System.out.println("A");
ret1 = appelBloquant1();
System.out.println("B");
ret2 = appelBloquant2();
System.out.println("C");
ret3 = appelBloquant3();
</code></pre>

<p>Il est l'est d'autant plus que les codes de retour ne sont pour l'instant pas traités. Deux solutions sont alors possibles, soit continuer à faire évoluer le pattern, soit utiliser une bibliothèque offrant une vision simplifiée du patterns des callbacks sous le nom d'un paradygme commun.</p>

<p>Les promesses (implantée par Q, ou fibers()), Asynch, ou XXX sont de telles bibliothèques.</p>

<p><strong><em>Exercice 6</em></strong> Proposez un modèle standard de gestion des codes de retour.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>&copy; Stéphane Frénot, Département Télécommunications, cours ELP<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</body>
</html>